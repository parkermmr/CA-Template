#!/bin/bash

set -e

# Script version
VERSION="1.0.0"

# Paths
CA_DIR=~/CA
DEFAULT_OUTPUT_DIR=~/.secrets
CONFIG_FILE="${CA_DIR}/.generate-certs.conf"

# Default certificate subject values (can be overridden in config file)
DEFAULT_COUNTRY="${CERT_COUNTRY:-AU}"
DEFAULT_ORGANIZATION="${CERT_ORGANIZATION:-Community}"
DEFAULT_OU_COMMUNITY="${CERT_OU_COMMUNITY:-OpenSource}"
DEFAULT_OU_UNIT="${CERT_OU_UNIT:-Cloud}"
DEFAULT_OU_TYPE="${CERT_OU_TYPE:-Self Signed}"
DEFAULT_OU_ENTITY="${CERT_OU_ENTITY:-Services}"

# Load config file if it exists
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Default values
CERT_TYPE="combined"
CERT_SUBJECT_TYPE="service"  # or "person"
GENERATE_KEYSTORE=false
GENERATE_JKS_KEYSTORE=false
GENERATE_TRUSTSTORE=false
GENERATE_PEM_BUNDLE=false
ARCHIVE_CSR=true
CLEANUP_OLD=false
NUM_INSTANCES=1
SERVICE_NAME=""
OUTPUT_DIR=""
KEY_PASSWORD=""
KEYSTORE_PASSWORD=""
TRUSTSTORE_PASSWORD=""
SEPARATE_DIRS=true
SETUP_CA=false
GENERATE_TEMPLATES=false

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

#############################################
# Helper Functions
#############################################

print_info() {
    echo "[INFO] $1"
}

print_success() {
    echo "[OK] $1"
}

print_warning() {
    echo "[WARN] $1"
}

print_error() {
    echo "[ERROR] $1"
}

show_help() {
    cat << EOF
Certificate Generation Script v${VERSION}

Usage: $(basename $0) [OPTIONS]

CA Setup:
    --setup-ca                  Set up Certificate Authority (first time only)

Certificate Generation:
Required:
    -s, --service NAME          Service name (e.g., kafka, grafana, prometheus)
    OR
    -p, --person NAME           Person name for personal certificate

Optional:
    -t, --type TYPE             Certificate type: server, client, combined (default: combined)
    -n, --instances NUM         Number of instances to generate (default: 1)
    -o, --output DIR            Output directory (default: ~/.secrets/SERVICE)
    --template                  Generate template .ext files and exit
    
Keystore/Truststore:
    --keystore                  Generate PKCS12 keystore
    --jks                       Generate JKS keystore (in addition to PKCS12 if --keystore used)
    --truststore                Generate JKS truststore
    --pem-bundle                Generate PEM bundle (cert + key + CA)
    --key-pass PASS             Private key password (default: no password)
    --keystore-pass PASS        Keystore password (auto-generated if not provided)
    --truststore-pass PASS      Truststore password (auto-generated if not provided)
    
Options:
    --single-dir                Put all instances in single directory (not separate dirs)
    --cleanup                   Clean up existing certificates before generating
    --no-archive                Don't archive CSR files
    
    -h, --help                  Show this help message
    -v, --version               Show version

Configuration:
    Defaults can be set in: ${CONFIG_FILE}
    Or via environment variables:
        CERT_COUNTRY           Country code (default: AU)
        CERT_ORGANIZATION      Organization name (default: Community)
        CERT_OU_COMMUNITY      Organizational Unit - Community (default: OpenSource)
        CERT_OU_UNIT           Organizational Unit - Unit (default: Cloud)
        CERT_OU_TYPE           Organizational Unit - Type (default: Self Signed)
        CERT_OU_ENTITY         Organizational Unit - Entity (default: Services)

Extension Files:
    - Client certificates: .ext files are optional (will use default client_cert)
    - Server/Combined: .ext files required with minimum 2 DNS names
    - Use --template to generate starter .ext files

Examples:
    # First time: Set up the CA
    $(basename $0) --setup-ca

    # Generate template files
    $(basename $0) -s kafka -n 3 -t combined --template

    # Generate 3 Kafka broker certificates with keystores
    $(basename $0) -s kafka -n 3 --keystore --truststore --cleanup

    # Generate certificates with both PKCS12 and JKS keystores
    $(basename $0) -s myservice --keystore --jks --truststore

    # Generate client certificate with password-protected key
    $(basename $0) -p "John Doe" -t client --keystore --key-pass "mySecurePassword"

    # Generate server certificate (needs .ext with 2+ DNS names)
    $(basename $0) -s grafana -t server --keystore --truststore

EOF
}

show_version() {
    echo "Certificate Generation Script v${VERSION}"
}

#############################################
# Template Generation Functions
#############################################

generate_templates() {
    print_info "Generating template files for: $SERVICE_NAME"
    echo ""
    
    mkdir -p "$OUTPUT_DIR"
    
    case $CERT_TYPE in
        server)
            generate_server_templates
            ;;
        client)
            generate_client_templates
            ;;
        combined)
            generate_combined_templates
            ;;
    esac
    
    print_success "Template files generated in: $OUTPUT_DIR"
    echo ""
    echo "Next steps:"
    echo "1. Edit the .ext files to add your DNS names, IPs, etc."
    echo "2. Run the certificate generation command without --template"
    echo ""
    exit 0
}

generate_server_templates() {
    if [ $NUM_INSTANCES -eq 1 ]; then
        cat > "$OUTPUT_DIR/${SERVICE_NAME}.ext" << 'EOF'
# Server Certificate Extension File
# Edit this file to customize your server certificate

basicConstraints                   = CA:FALSE
nsCertType                         = server
nsComment                          = "OpenSSL Generated Server Certificate"
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer:always
keyUsage                           = critical, digitalSignature, keyEncipherment
extendedKeyUsage                   = serverAuth
subjectAltName                     = @alt_names

[alt_names]
# REQUIRED: Minimum 2 DNS names for server certificates
DNS.1 = server.internal.local
DNS.2 = server.example.com

# Optional: Add more DNS names
# DNS.3 = server.example.org

# Optional: Add IP addresses
# IP.1  = 192.168.1.100
# IP.2  = 10.0.0.50
EOF
        print_success "Created: ${SERVICE_NAME}.ext"
    else
        for ((i=0; i<$NUM_INSTANCES; i++)); do
            cat > "$OUTPUT_DIR/${SERVICE_NAME}-${i}.ext" << EOF
# Server Certificate Extension File - Instance ${i}
# Edit this file to customize your server certificate

basicConstraints                   = CA:FALSE
nsCertType                         = server
nsComment                          = "OpenSSL Generated Server Certificate"
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer:always
keyUsage                           = critical, digitalSignature, keyEncipherment
extendedKeyUsage                   = serverAuth
subjectAltName                     = @alt_names

[alt_names]
# REQUIRED: Minimum 2 DNS names for server certificates
DNS.1 = ${SERVICE_NAME}.internal.local
DNS.2 = ${SERVICE_NAME}-${i}.example.com

# Optional: Add more DNS names
# DNS.3 = ${SERVICE_NAME}-${i}.example.org

# Optional: Add IP addresses
# IP.1  = 192.168.1.$((100+i))
EOF
            print_success "Created: ${SERVICE_NAME}-${i}.ext"
        done
    fi
}

generate_client_templates() {
    print_info "Client certificates don't require .ext files"
    print_info "Default client_cert extension will be used"
    echo ""
    print_info "If you want custom SANs, create an .ext file manually:"
    echo ""
    
    if [ $NUM_INSTANCES -eq 1 ]; then
        cat > "$OUTPUT_DIR/${SERVICE_NAME}.ext.example" << 'EOF'
# Client Certificate Extension File (Optional)
# Rename this to .ext (remove .example) if you want custom SANs

basicConstraints                   = CA:FALSE
nsCertType                         = client, email
nsComment                          = "OpenSSL Generated Client Certificate"
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer:always
keyUsage                           = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage                   = clientAuth, emailProtection
subjectAltName                     = @alt_names

[alt_names]
# Optional: Add email addresses
email.1 = user@example.com

# Optional: Add DNS names
# DNS.1 = client.example.com
EOF
        print_info "Created example file: ${SERVICE_NAME}.ext.example"
    fi
}

generate_combined_templates() {
    if [ $NUM_INSTANCES -eq 1 ]; then
        cat > "$OUTPUT_DIR/${SERVICE_NAME}.ext" << 'EOF'
# Combined Certificate Extension File
# Edit this file to customize your client+server certificate

basicConstraints                   = CA:FALSE
nsCertType                         = client, server, email
nsComment                          = "OpenSSL Generated Client+Server Certificate"
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer:always
keyUsage                           = critical, digitalSignature, keyEncipherment, nonRepudiation
extendedKeyUsage                   = serverAuth, clientAuth, emailProtection
subjectAltName                     = @alt_names

[alt_names]
# REQUIRED: Minimum 2 DNS names for combined certificates
DNS.1 = service.internal.local
DNS.2 = service.example.com

# Optional: Add more DNS names
# DNS.3 = service.example.org

# Optional: Add IP addresses
# IP.1  = 192.168.1.100

# Optional: Add email addresses
# email.1 = service@example.com
EOF
        print_success "Created: ${SERVICE_NAME}.ext"
    else
        for ((i=0; i<$NUM_INSTANCES; i++)); do
            cat > "$OUTPUT_DIR/${SERVICE_NAME}-${i}.ext" << EOF
# Combined Certificate Extension File - Instance ${i}
# Edit this file to customize your client+server certificate

basicConstraints                   = CA:FALSE
nsCertType                         = client, server, email
nsComment                          = "OpenSSL Generated Client+Server Certificate"
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer:always
keyUsage                           = critical, digitalSignature, keyEncipherment, nonRepudiation
extendedKeyUsage                   = serverAuth, clientAuth, emailProtection
subjectAltName                     = @alt_names

[alt_names]
# REQUIRED: Minimum 2 DNS names for combined certificates
DNS.1 = ${SERVICE_NAME}.internal.local
DNS.2 = ${SERVICE_NAME}-${i}.example.com

# Optional: Add more DNS names
# DNS.3 = ${SERVICE_NAME}-${i}.example.org

# Optional: Add IP addresses
# IP.1  = 192.168.1.$((100+i))

# Optional: Add email addresses
# email.1 = ${SERVICE_NAME}@example.com
EOF
            print_success "Created: ${SERVICE_NAME}-${i}.ext"
        done
    fi
}

#############################################
# Config File Management
#############################################

create_default_config() {
    print_info "Creating default configuration file..."
    
    cat > "$CONFIG_FILE" << EOF
# Certificate Generation Configuration
# Generated: $(date)

# Certificate Subject Defaults
CERT_COUNTRY="AU"
CERT_ORGANIZATION="Community"
CERT_OU_COMMUNITY="OpenSource"
CERT_OU_UNIT="Cloud"
CERT_OU_TYPE="Self Signed"
CERT_OU_ENTITY="Services"

# Output Defaults
DEFAULT_OUTPUT_DIR="\$HOME/.secrets"

# Certificate Defaults
DEFAULT_CERT_TYPE="combined"
DEFAULT_KEY_SIZE="4096"
DEFAULT_VALIDITY_DAYS="1000"
EOF
    
    chmod 644 "$CONFIG_FILE"
    print_success "Configuration file created at: $CONFIG_FILE"
    echo ""
    echo "Edit this file to customize default values for certificate generation."
    echo ""
}

#############################################
# CA Setup Function
#############################################

setup_ca() {
    echo "=========================================="
    echo "Certificate Authority Setup"
    echo "=========================================="
    echo ""

    # Check if CA already exists
    if [ -f "$CA_DIR/root-ca.cert" ] || [ -f "$CA_DIR/private/root-ca.key" ]; then
        print_warning "CA already exists at $CA_DIR"
        echo ""
        ls -la $CA_DIR/root-ca.cert 2>/dev/null || true
        ls -la $CA_DIR/private/root-ca.key 2>/dev/null || true
        echo ""
        read -p "Do you want to DELETE the existing CA and create a new one? (yes/no): " confirm
        if [ "$confirm" != "yes" ]; then
            print_info "CA setup cancelled."
            exit 0
        fi
        echo ""
        print_warning "DELETING existing CA..."
        rm -rf $CA_DIR
    fi

    # Create CA directory
    mkdir -p $CA_DIR
    cd $CA_DIR

    print_info "Creating CA directory structure..."

    # Create subdirectories
    mkdir -p certs              # Issued certificates
    mkdir -p private            # Private keys
    mkdir -p csr                # Certificate signing requests (archive)
    mkdir -p crl                # Certificate revocation lists
    mkdir -p newcerts           # Temporary new certificates

    # Set proper permissions
    chmod 700 private
    chmod 755 certs csr crl newcerts

    print_success "Directory structure created"
    echo ""

    # Create database files
    print_info "Initializing CA database..."
    touch index.txt
    touch index.txt.attr
    echo '01' > serial.txt
    echo '01' > crlnumber.txt

    print_success "Database initialized"
    echo ""

    # Create default config file
    create_default_config

    # Create the openssl-ca.cnf file
    print_info "Creating OpenSSL configuration..."
    cat > openssl-ca.cnf << 'EOF'
HOME                               = .
RANDFILE                           = $ENV::HOME/.rnd

####################################################################
[ ca ]
default_ca                         = CA_default

[ CA_default ]

dir                                = .
certs                              = $dir/certs              # Where issued certs are kept
crl_dir                            = $dir/crl                # Where CRLs are kept
database                           = $dir/index.txt          # Database index file
new_certs_dir                      = $dir/certs              # Default place for new certs
certificate                        = $dir/root-ca.cert       # The CA certificate
serial                             = $dir/serial.txt         # The current serial number
crlnumber                          = $dir/crlnumber.txt      # The current CRL number
crl                                = $crl_dir/crl.pem        # The current CRL
private_key                        = $dir/private/root-ca.key # The CA private key
RANDFILE                           = $dir/private/.rand      # Private random number file

default_days                       = 1000                    # How long to certify for
default_crl_days                   = 30                      # How long before next CRL
default_md                         = sha256                  # Use public key default MD
preserve                           = no                      # Keep passed DN ordering

x509_extensions                    = ca_extensions           # The extensions to add to the cert

email_in_dn                        = no                      # Don't concat the email in the DN
copy_extensions                    = copy                    # Required to copy SANs from CSR to cert

####################################################################
[ req ]
default_bits                       = 4096
default_keyfile                    = private/root-ca.key
distinguished_name                 = ca_distinguished_name
x509_extensions                    = ca_extensions
string_mask                        = utf8only

####################################################################
[ ca_distinguished_name ]
countryName                        = Country Name (2 letter code)
countryName_default                = AU

organizationName                   = Organization Name
organizationName_default           = Community

0.organizationalUnitName           = Organizational Community
0.organizationalUnitName_default   = OpenSource

1.organizationalUnitName           = Organizational Unit
1.organizationalUnitName_default   = Cloud

2.organizationalUnitName           = Organizational Type
2.organizationalUnitName_default   = Self Signed

3.organizationalUnitName           = Organizational Entity (eg, People, Services)
3.organizationalUnitName_default   = Services

commonName                         = Common Name (e.g. server FQDN or YOUR name)

emailAddress                       = Email Address

####################################################################
[ ca_extensions ]

subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid:always, issuer
basicConstraints                   = critical, CA:true
keyUsage                           = keyCertSign, cRLSign

####################################################################
[ signing_policy ]
countryName                        = supplied
organizationName                   = supplied
organizationalUnitName             = supplied
organizationalUnitName             = supplied
organizationalUnitName             = supplied
organizationalUnitName             = optional
commonName                         = supplied
emailAddress                       = optional

####################################################################
[ signing_req ]
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer
basicConstraints                   = CA:FALSE
keyUsage                           = digitalSignature, keyEncipherment

####################################################################
[ server_cert ]
basicConstraints                   = CA:FALSE
nsCertType                         = server
nsComment                          = "OpenSSL Generated Server Certificate"
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer:always
keyUsage                           = critical, digitalSignature, keyEncipherment
extendedKeyUsage                   = serverAuth

####################################################################
[ client_cert ]
basicConstraints                   = CA:FALSE
nsCertType                         = client, email
nsComment                          = "OpenSSL Generated Client Certificate"
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer:always
keyUsage                           = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage                   = clientAuth, emailProtection

####################################################################
[ combined_cert ]
basicConstraints                   = CA:FALSE
nsCertType                         = client, server, email
nsComment                          = "OpenSSL Generated Client+Server Certificate"
subjectKeyIdentifier               = hash
authorityKeyIdentifier             = keyid,issuer:always
keyUsage                           = critical, digitalSignature, keyEncipherment, nonRepudiation
extendedKeyUsage                   = serverAuth, clientAuth, emailProtection
EOF

    print_success "Configuration file created"
    echo ""

    # Generate root CA certificate
    print_info "Generating Root CA certificate..."
    echo ""
    echo "You will be prompted for CA details:"
    echo ""

    openssl req -x509 -config openssl-ca.cnf \
      -newkey rsa:4096 -sha256 -nodes \
      -out root-ca.cert \
      -keyout private/root-ca.key \
      -days 3650

    chmod 600 private/root-ca.key
    chmod 644 root-ca.cert

    echo ""
    print_success "Root CA certificate generated"
    echo ""

    # Display CA info
    echo "=========================================="
    echo "CA Setup Complete!"
    echo "=========================================="
    echo ""
    echo "CA Directory: $CA_DIR"
    echo ""
    echo "Directory structure:"
    echo "-------------------"
    tree -L 2 $CA_DIR 2>/dev/null || ls -la $CA_DIR
    echo ""
    echo "Root CA Certificate:"
    echo "-------------------"
    openssl x509 -in root-ca.cert -noout -subject -issuer -dates
    echo ""
    echo "Files created:"
    echo "  root-ca.cert              - CA public certificate (share this)"
    echo "  private/root-ca.key       - CA private key (KEEP SECURE!)"
    echo "  openssl-ca.cnf            - CA configuration"
    echo "  .generate-certs.conf       - Default certificate values"
    echo "  index.txt                 - Certificate database"
    echo "  serial.txt                - Certificate serial counter"
    echo ""
    echo "Subdirectories:"
    echo "  certs/    - Issued certificates (.pem files)"
    echo "  private/  - Private keys (restricted access)"
    echo "  csr/      - Certificate requests archive"
    echo "  crl/      - Certificate revocation lists"
    echo ""
    print_success "CA setup complete!"
    echo ""
    echo "Next steps:"
    echo "1. Backup private/root-ca.key to a secure location"
    echo "2. Edit .generate-certs.conf to customize default values"
    echo "3. Distribute root-ca.cert to systems that need to trust this CA"
    echo "4. Generate certificates using: $(basename $0) -s SERVICE_NAME"
    echo ""
    
    exit 0
}

#############################################
# Validation Functions
#############################################

validate_ca() {
    print_info "Validating CA setup..."
    
    if [ ! -d "$CA_DIR" ]; then
        print_error "CA directory not found at $CA_DIR"
        print_info "Run: $(basename $0) --setup-ca to set up the CA first"
        exit 1
    fi
    
    local required_files=(
        "$CA_DIR/openssl-ca.cnf"
        "$CA_DIR/root-ca.cert"
        "$CA_DIR/private/root-ca.key"
        "$CA_DIR/index.txt"
        "$CA_DIR/serial.txt"
    )
    
    for file in "${required_files[@]}"; do
        if [ ! -f "$file" ]; then
            print_error "Required file not found: $file"
            print_info "Run: $(basename $0) --setup-ca to set up the CA first"
            exit 1
        fi
    done
    
    print_success "CA validation passed"
}

validate_ext_file() {
    local ext_file=$1
    local instance_name=$2
    
    # Check if file exists
    if [ ! -f "$ext_file" ]; then
        return 1
    fi
    
    # Validate required fields based on certificate type
    local required_fields=()
    local min_dns_count=0
    
    case $CERT_TYPE in
        server)
            required_fields=("basicConstraints" "subjectKeyIdentifier" "authorityKeyIdentifier" "keyUsage" "extendedKeyUsage")
            min_dns_count=2
            # Check for serverAuth
            if ! grep -q "extendedKeyUsage.*serverAuth" "$ext_file"; then
                print_error "Extension file $ext_file missing 'serverAuth' in extendedKeyUsage"
                return 1
            fi
            ;;
        client)
            required_fields=("basicConstraints" "subjectKeyIdentifier" "authorityKeyIdentifier" "keyUsage" "extendedKeyUsage")
            # Check for clientAuth
            if ! grep -q "extendedKeyUsage.*clientAuth" "$ext_file"; then
                print_error "Extension file $ext_file missing 'clientAuth' in extendedKeyUsage"
                return 1
            fi
            ;;
        combined)
            required_fields=("basicConstraints" "subjectKeyIdentifier" "authorityKeyIdentifier" "keyUsage" "extendedKeyUsage")
            min_dns_count=2
            # Check for both serverAuth and clientAuth
            if ! grep -q "extendedKeyUsage.*serverAuth" "$ext_file" || ! grep -q "extendedKeyUsage.*clientAuth" "$ext_file"; then
                print_error "Extension file $ext_file missing 'serverAuth' and/or 'clientAuth' in extendedKeyUsage"
                return 1
            fi
            ;;
    esac
    
    # Check required fields
    for field in "${required_fields[@]}"; do
        if ! grep -q "^${field}" "$ext_file"; then
            print_error "Extension file $ext_file missing required field: $field"
            return 1
        fi
    done
    
    # Check minimum DNS count for server/combined certificates
    if [ $min_dns_count -gt 0 ]; then
        local dns_count=$(grep -c "^DNS\." "$ext_file" || echo "0")
        if [ "$dns_count" -lt "$min_dns_count" ]; then
            print_error "Extension file $ext_file requires at least $min_dns_count DNS names (found: $dns_count)"
            print_info "Server and combined certificates must have at least 2 DNS names"
            return 1
        fi
    fi
    
    return 0
}

validate_ext_files() {
    print_info "Validating extension files..."
    
    # Client certificates don't require .ext files
    if [ "$CERT_TYPE" = "client" ]; then
        print_info "Client certificates: .ext files are optional"
        
        if [ $NUM_INSTANCES -eq 1 ]; then
            local ext_file="$OUTPUT_DIR/${SERVICE_NAME}.ext"
            if [ -f "$ext_file" ]; then
                print_info "Found optional .ext file, validating..."
                if ! validate_ext_file "$ext_file" "$SERVICE_NAME"; then
                    print_error "Validation failed for $ext_file"
                    exit 1
                fi
                print_success "Extension file validated"
            else
                print_info "No .ext file found, will use default client_cert extension"
            fi
        else
            # Check each instance
            for ((i=0; i<$NUM_INSTANCES; i++)); do
                local ext_file="$OUTPUT_DIR/${SERVICE_NAME}-${i}.ext"
                if [ -f "$ext_file" ]; then
                    print_info "Found optional .ext file for instance $i, validating..."
                    if ! validate_ext_file "$ext_file" "${SERVICE_NAME}-${i}"; then
                        print_error "Validation failed for $ext_file"
                        exit 1
                    fi
                fi
            done
            print_info "Will use default client_cert extension for instances without .ext files"
        fi
        print_success "Extension file validation passed"
        return 0
    fi
    
    # Server and combined certificates REQUIRE .ext files
    if [ $NUM_INSTANCES -eq 1 ]; then
        local ext_file="$OUTPUT_DIR/${SERVICE_NAME}.ext"
        if [ ! -f "$ext_file" ]; then
            print_error "Extension file not found: $ext_file"
            print_info "Server and combined certificates require .ext files with at least 2 DNS names"
            print_info "Run with --template to generate template files"
            exit 1
        fi
        
        if ! validate_ext_file "$ext_file" "$SERVICE_NAME"; then
            print_error "Validation failed for $ext_file"
            print_info "Run with --template to generate correct template"
            exit 1
        fi
    else
        for ((i=0; i<$NUM_INSTANCES; i++)); do
            local ext_file="$OUTPUT_DIR/${SERVICE_NAME}-${i}.ext"
            if [ ! -f "$ext_file" ]; then
                print_error "Extension file not found: $ext_file"
                print_info "Create .ext files for each instance: ${SERVICE_NAME}-0.ext, ${SERVICE_NAME}-1.ext, ..."
                print_info "Run with --template to generate template files"
                exit 1
            fi
            
            if ! validate_ext_file "$ext_file" "${SERVICE_NAME}-${i}"; then
                print_error "Validation failed for $ext_file"
                print_info "Run with --template to generate correct templates"
                exit 1
            fi
        done
    fi
    
    print_success "Extension file validation passed"
}

#############################################
# Certificate Management Functions
#############################################

cleanup_existing() {
    print_warning "Cleaning up existing certificates for $SERVICE_NAME..."
    
    if [ "$SEPARATE_DIRS" = true ] && [ $NUM_INSTANCES -gt 1 ]; then
        for ((i=0; i<$NUM_INSTANCES; i++)); do
            local dir="$OUTPUT_DIR/${SERVICE_NAME}-${i}"
            if [ -d "$dir" ]; then
                rm -rf "$dir"
                print_success "Removed $dir"
            fi
        done
    else
        rm -f "$OUTPUT_DIR/${SERVICE_NAME}"*.{key,csr,crt,p12,jks,pem} 2>/dev/null || true
        print_success "Removed certificate files from $OUTPUT_DIR"
    fi
    
    # Revoke from CA database
    revoke_existing_certs
}

revoke_existing_certs() {
    print_info "Checking CA database for existing certificates..."
    
    cd "$CA_DIR"
    
    local revoked_count=0
    
    # Read the index.txt file line by line
    while IFS= read -r line; do
        # Skip empty lines
        [ -z "$line" ] && continue
        
        # Check if this line contains our service certificate
        if [[ $line == *"CN=${SERVICE_NAME}"* ]] || [[ $line == *"CN=svc-${SERVICE_NAME}"* ]]; then
            # Extract status (first character)
            local status="${line:0:1}"
            
            # Only process if Valid
            if [ "$status" = "V" ]; then
                # Extract CN for display
                local cn=$(echo "$line" | grep -o "CN=[^/]*" | cut -d= -f2)
                # Extract serial number (4th tab-separated field)
                local serial=$(echo "$line" | awk -F'\t' '{print $4}')
                # Extract expiry (2nd tab-separated field)
                local expiry=$(echo "$line" | awk -F'\t' '{print $2}')
                
                print_info "Revoking: $cn (serial: $serial)"
                
                local cert_file="certs/${serial}.pem"
                
                if [ -f "$cert_file" ]; then
                    if openssl ca -config openssl-ca.cnf -revoke "$cert_file" 2>/dev/null; then
                        print_success "Revoked successfully"
                        revoked_count=$((revoked_count + 1))
                    else
                        print_warning "Failed to revoke via openssl, updating manually"
                        # Manually update the line
                        local revoke_date=$(date -u +%y%m%d%H%M%SZ)
                        sed -i "s|^V\t${expiry}\t\t${serial}\t|R\t${expiry}\t${revoke_date}\t${serial}\t|" index.txt
                        revoked_count=$((revoked_count + 1))
                    fi
                else
                    print_warning "Certificate file not found: $cert_file"
                    print_info "Updating database manually..."
                    # Manually update the line
                    local revoke_date=$(date -u +%y%m%d%H%M%SZ)
                    sed -i "s|^V\t${expiry}\t\t${serial}\t|R\t${expiry}\t${revoke_date}\t${serial}\t|" index.txt
                    revoked_count=$((revoked_count + 1))
                fi
            fi
        fi
    done < index.txt
    
    if [ $revoked_count -gt 0 ]; then
        print_success "Revoked $revoked_count certificate(s)"
    fi
}

archive_csr() {
    local csr_file=$1
    local cert_name=$2
    
    if [ "$ARCHIVE_CSR" = true ] && [ -f "$csr_file" ]; then
        mkdir -p "$CA_DIR/csr"
        local archive_name="${cert_name}-$(date +%Y%m%d-%H%M%S).csr"
        cp "$csr_file" "$CA_DIR/csr/${archive_name}"
        print_success "Archived CSR: $archive_name"
    fi
}

#############################################
# Certificate Generation Functions
#############################################

generate_certificate() {
    local instance_num=$1
    local cert_name="${SERVICE_NAME}"
    local cn_name
    local instance_dir="$OUTPUT_DIR"
    local ext_file="$OUTPUT_DIR/${SERVICE_NAME}.ext"
    local use_ext_file=true
    
    # Build CN based on type (service or person)
    if [ "$CERT_SUBJECT_TYPE" = "person" ]; then
        cn_name="${SERVICE_NAME}"
    else
        cn_name="svc-${SERVICE_NAME}"
    fi
    
    # Adjust names and paths for multiple instances
    if [ $NUM_INSTANCES -gt 1 ]; then
        cert_name="${SERVICE_NAME}-${instance_num}"
        
        if [ "$CERT_SUBJECT_TYPE" = "service" ]; then
            cn_name="svc-${SERVICE_NAME}-${instance_num}"
        else
            cn_name="${SERVICE_NAME}-${instance_num}"
        fi
        
        ext_file="$OUTPUT_DIR/${SERVICE_NAME}-${instance_num}.ext"
        
        if [ "$SEPARATE_DIRS" = true ]; then
            instance_dir="$OUTPUT_DIR/${cert_name}"
            mkdir -p "$instance_dir"
        fi
    fi
    
    # Check if ext file exists (for client certs it's optional)
    if [ ! -f "$ext_file" ] && [ "$CERT_TYPE" = "client" ]; then
        use_ext_file=false
        print_info "No .ext file found for client cert, using default client_cert extension"
    fi
    
    local key_file="$instance_dir/${cert_name}.key"
    local csr_file="$instance_dir/${cert_name}.csr"
    local crt_file="$instance_dir/${cert_name}.crt"
    
    print_info "Generating certificate: $cert_name"
    
    # Build subject DN based on config
    local subject="/C=${DEFAULT_COUNTRY}/O=${DEFAULT_ORGANIZATION}"
    subject="${subject}/OU=${DEFAULT_OU_COMMUNITY}"
    subject="${subject}/OU=${DEFAULT_OU_UNIT}"
    subject="${subject}/OU=${DEFAULT_OU_TYPE}"
    subject="${subject}/OU=${DEFAULT_OU_ENTITY}"
    subject="${subject}/CN=${cn_name}"
    
    # Generate private key and CSR
    cd "$CA_DIR"
    
    # Determine if we need password protection for the key
    if [ -n "$KEY_PASSWORD" ]; then
        # Generate encrypted key
        if ! openssl req -new -newkey rsa:4096 \
            -keyout "$key_file" \
            -out "$csr_file" \
            -config openssl-ca.cnf \
            -subj "$subject" \
            -passout "pass:${KEY_PASSWORD}" \
            2>&1 | grep -v "Generating"; then
            print_error "Failed to generate private key and CSR"
            return 1
        fi
        
        # Save password
        echo "KEY_PASSWORD_${cert_name//-/_}='${KEY_PASSWORD}'" >> "$OUTPUT_DIR/passwords.env"
        
        print_success "Generated encrypted private key and CSR"
    else
        # Generate unencrypted key
        if ! openssl req -new -newkey rsa:4096 -nodes \
            -keyout "$key_file" \
            -out "$csr_file" \
            -config openssl-ca.cnf \
            -subj "$subject" \
            2>&1 | grep -v "Generating"; then
            print_error "Failed to generate private key and CSR"
            return 1
        fi
        
        print_success "Generated private key and CSR"
    fi
    
    # Sign the certificate
    print_info "Signing certificate with CA..."
    
    if [ "$use_ext_file" = true ]; then
        # Use external .ext file
        if ! openssl ca -batch -config openssl-ca.cnf \
            -policy signing_policy \
            -extfile "$ext_file" \
            -out "$crt_file" \
            -infiles "$csr_file" \
            2>&1 | tee /tmp/openssl_ca_output.log | grep -v "^Using configuration"; then
            print_error "Failed to sign certificate"
            echo "OpenSSL output:"
            cat /tmp/openssl_ca_output.log
            return 1
        fi
    else
        # Use default extension from openssl-ca.cnf
        if ! openssl ca -batch -config openssl-ca.cnf \
            -policy signing_policy \
            -extensions ${CERT_TYPE}_cert \
            -out "$crt_file" \
            -infiles "$csr_file" \
            2>&1 | tee /tmp/openssl_ca_output.log | grep -v "^Using configuration"; then
            print_error "Failed to sign certificate"
            echo "OpenSSL output:"
            cat /tmp/openssl_ca_output.log
            return 1
        fi
    fi
    
    print_success "Signed certificate"
    
    # Archive CSR
    archive_csr "$csr_file" "$cert_name"
    
    # Copy CA certificate
    cp "$CA_DIR/root-ca.cert" "$instance_dir/root-ca.cert"
    
    # Generate keystore if requested
    if [ "$GENERATE_KEYSTORE" = true ]; then
        generate_keystore "$instance_dir" "$cert_name" "$key_file" "$crt_file"
    fi
    
    # Generate JKS keystore if requested
    if [ "$GENERATE_JKS_KEYSTORE" = true ]; then
        generate_jks_keystore "$instance_dir" "$cert_name" "$key_file" "$crt_file"
    fi
    
    # Generate truststore if requested
    if [ "$GENERATE_TRUSTSTORE" = true ]; then
        generate_truststore "$instance_dir" "$cert_name"
    fi
    
    # Generate PEM bundle if requested
    if [ "$GENERATE_PEM_BUNDLE" = true ]; then
        generate_pem_bundle "$instance_dir" "$cert_name" "$key_file" "$crt_file"
    fi
    
    # Set permissions
    chmod 600 "$key_file"
    chmod 644 "$crt_file"
    
    if [ "$GENERATE_KEYSTORE" = true ]; then
        chmod 600 "$instance_dir"/*.p12 2>/dev/null || true
    fi
    
    if [ "$GENERATE_JKS_KEYSTORE" = true ]; then
        chmod 600 "$instance_dir"/*-keystore.jks 2>/dev/null || true
    fi
    
    if [ "$GENERATE_TRUSTSTORE" = true ]; then
        chmod 600 "$instance_dir"/*-truststore.jks 2>/dev/null || true
    fi
    
    print_success "Certificate generation complete: $cert_name"
    echo ""
}

generate_keystore() {
    local dir=$1
    local name=$2
    local key_file=$3
    local crt_file=$4
    
    local keystore_file="$dir/${name}-keystore.p12"
    local password="${KEYSTORE_PASSWORD:-$(openssl rand -base64 32)}"
    
    print_info "Creating PKCS12 keystore..."
    
    # If private key is password-protected, we need to provide the password
    if [ -n "$KEY_PASSWORD" ]; then
        openssl pkcs12 -export \
            -out "$keystore_file" \
            -inkey "$key_file" \
            -in "$crt_file" \
            -certfile "$CA_DIR/root-ca.cert" \
            -name "$name" \
            -passin "pass:${KEY_PASSWORD}" \
            -password "pass:${password}" \
            2>/dev/null
    else
        openssl pkcs12 -export \
            -out "$keystore_file" \
            -inkey "$key_file" \
            -in "$crt_file" \
            -certfile "$CA_DIR/root-ca.cert" \
            -name "$name" \
            -password "pass:${password}" \
            2>/dev/null
    fi
    
    # Save password
    echo "KEYSTORE_PASSWORD_${name//-/_}='${password}'" >> "$OUTPUT_DIR/passwords.env"
    
    print_success "Created keystore: ${name}-keystore.p12"
}

generate_jks_keystore() {
    local dir=$1
    local name=$2
    local key_file=$3
    local crt_file=$4
    
    local jks_keystore_file="$dir/${name}-keystore.jks"
    local password="${KEYSTORE_PASSWORD:-$(openssl rand -base64 32)}"
    
    print_info "Creating JKS keystore..."
    
    # First create a temporary PKCS12 file
    local temp_p12="/tmp/${name}-temp.p12"
    
    # If private key is password-protected, we need to provide the password
    if [ -n "$KEY_PASSWORD" ]; then
        openssl pkcs12 -export \
            -out "$temp_p12" \
            -inkey "$key_file" \
            -in "$crt_file" \
            -certfile "$CA_DIR/root-ca.cert" \
            -name "$name" \
            -passin "pass:${KEY_PASSWORD}" \
            -password "pass:${password}" \
            2>/dev/null
    else
        openssl pkcs12 -export \
            -out "$temp_p12" \
            -inkey "$key_file" \
            -in "$crt_file" \
            -certfile "$CA_DIR/root-ca.cert" \
            -name "$name" \
            -password "pass:${password}" \
            2>/dev/null
    fi
    
    # Convert PKCS12 to JKS
    keytool -importkeystore \
        -srckeystore "$temp_p12" \
        -srcstoretype PKCS12 \
        -srcstorepass "$password" \
        -destkeystore "$jks_keystore_file" \
        -deststoretype JKS \
        -deststorepass "$password" \
        -noprompt \
        2>/dev/null
    
    # Clean up temp file
    rm -f "$temp_p12"
    
    # Save password if not already saved
    if ! grep -q "KEYSTORE_PASSWORD_${name//-/_}=" "$OUTPUT_DIR/passwords.env" 2>/dev/null; then
        echo "KEYSTORE_PASSWORD_${name//-/_}='${password}'" >> "$OUTPUT_DIR/passwords.env"
    fi
    
    print_success "Created JKS keystore: ${name}-keystore.jks"
}

generate_truststore() {
    local dir=$1
    local name=$2
    
    local truststore_file="$dir/${name}-truststore.jks"
    local password="${TRUSTSTORE_PASSWORD:-$(openssl rand -base64 32)}"
    
    print_info "Creating JKS truststore..."
    
    keytool -import -trustcacerts \
        -alias root-ca \
        -file "$CA_DIR/root-ca.cert" \
        -keystore "$truststore_file" \
        -storepass "$password" \
        -noprompt \
        2>/dev/null
    
    # Save password
    echo "TRUSTSTORE_PASSWORD_${name//-/_}='${password}'" >> "$OUTPUT_DIR/passwords.env"
    
    print_success "Created truststore: ${name}-truststore.jks"
}

generate_pem_bundle() {
    local dir=$1
    local name=$2
    local key_file=$3
    local crt_file=$4
    
    local bundle_file="$dir/${name}-bundle.pem"
    
    print_info "Creating PEM bundle..."
    
    cat "$key_file" "$crt_file" "$CA_DIR/root-ca.cert" > "$bundle_file"
    chmod 600 "$bundle_file"
    
    print_success "Created PEM bundle: ${name}-bundle.pem"
}

#############################################
# Summary Functions
#############################################

print_summary() {
    echo ""
    echo "=========================================="
    echo "Certificate Generation Summary"
    echo "=========================================="
    echo ""
    echo "Service: $SERVICE_NAME"
    echo "Type: $CERT_TYPE"
    echo "Subject Type: $CERT_SUBJECT_TYPE"
    echo "Instances: $NUM_INSTANCES"
    echo "Output: $OUTPUT_DIR"
    
    if [ -n "$KEY_PASSWORD" ]; then
        echo "Private Key: Password protected"
    else
        echo "Private Key: No password"
    fi
    
    echo ""
    
    if [ "$GENERATE_KEYSTORE" = true ] || [ "$GENERATE_JKS_KEYSTORE" = true ] || [ "$GENERATE_TRUSTSTORE" = true ] || [ -n "$KEY_PASSWORD" ]; then
        echo "Passwords saved to: $OUTPUT_DIR/passwords.env"
        echo "Load with: source $OUTPUT_DIR/passwords.env"
        echo ""
    fi
    
    echo "Generated certificates:"
    echo "----------------------"
    
    if [ "$SEPARATE_DIRS" = true ] && [ $NUM_INSTANCES -gt 1 ]; then
        for ((i=0; i<$NUM_INSTANCES; i++)); do
            local cert_name="${SERVICE_NAME}-${i}"
            echo ""
            echo "$cert_name directory:"
            ls -lh "$OUTPUT_DIR/${cert_name}" 2>/dev/null | tail -n +2 | awk '{print "  " $0}'
        done
    else
        ls -lh "$OUTPUT_DIR"/${SERVICE_NAME}*.{key,csr,crt,p12,jks,pem} 2>/dev/null | awk '{print "  " $0}' || true
    fi
    
    echo ""
    echo "Files created per instance:"
    echo "  - ${SERVICE_NAME}-X.key   (private key)"
    echo "  - ${SERVICE_NAME}-X.csr   (certificate request)"
    echo "  - ${SERVICE_NAME}-X.crt   (signed certificate)"
    echo "  - root-ca.cert            (CA certificate)"
    
    if [ "$GENERATE_KEYSTORE" = true ]; then
        echo "  - ${SERVICE_NAME}-X-keystore.p12   (PKCS12 keystore)"
    fi
    
    if [ "$GENERATE_JKS_KEYSTORE" = true ]; then
        echo "  - ${SERVICE_NAME}-X-keystore.jks   (JKS keystore)"
    fi
    
    if [ "$GENERATE_TRUSTSTORE" = true ]; then
        echo "  - ${SERVICE_NAME}-X-truststore.jks (JKS truststore)"
    fi
    
    if [ "$GENERATE_PEM_BUNDLE" = true ]; then
        echo "  - ${SERVICE_NAME}-X-bundle.pem     (PEM bundle)"
    fi
    
    echo ""
    echo "CSRs archived in: $CA_DIR/csr/"
    echo ""
}

#############################################
# Main Script
#############################################

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --setup-ca)
            SETUP_CA=true
            shift
            ;;
        --template)
            GENERATE_TEMPLATES=true
            shift
            ;;
        -s|--service)
            SERVICE_NAME="$2"
            CERT_SUBJECT_TYPE="service"
            shift 2
            ;;
        -p|--person)
            SERVICE_NAME="$2"
            CERT_SUBJECT_TYPE="person"
            shift 2
            ;;
        -t|--type)
            CERT_TYPE="$2"
            shift 2
            ;;
        -n|--instances)
            NUM_INSTANCES="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --keystore)
            GENERATE_KEYSTORE=true
            shift
            ;;
        --jks)
            GENERATE_JKS_KEYSTORE=true
            shift
            ;;
        --truststore)
            GENERATE_TRUSTSTORE=true
            shift
            ;;
        --pem-bundle)
            GENERATE_PEM_BUNDLE=true
            shift
            ;;
        --key-pass)
            KEY_PASSWORD="$2"
            shift 2
            ;;
        --keystore-pass)
            KEYSTORE_PASSWORD="$2"
            shift 2
            ;;
        --truststore-pass)
            TRUSTSTORE_PASSWORD="$2"
            shift 2
            ;;
        --single-dir)
            SEPARATE_DIRS=false
            shift
            ;;
        --cleanup)
            CLEANUP_OLD=true
            shift
            ;;
        --no-archive)
            ARCHIVE_CSR=false
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
    esac
done

# If setup-ca flag is set, run CA setup and exit
if [ "$SETUP_CA" = true ]; then
    setup_ca
fi

# Validate required arguments
if [ -z "$SERVICE_NAME" ]; then
    print_error "Service or person name is required"
    echo "Use: $(basename $0) -s SERVICE_NAME  (for service)"
    echo "Or:  $(basename $0) -p PERSON_NAME   (for person)"
    echo "Or:  $(basename $0) --setup-ca       (to set up CA first)"
    echo "Use -h or --help for more information"
    exit 1
fi

# Set default output directory if not specified
if [ -z "$OUTPUT_DIR" ]; then
    OUTPUT_DIR="$DEFAULT_OUTPUT_DIR/$SERVICE_NAME"
fi

# Validate certificate type
if [[ ! "$CERT_TYPE" =~ ^(server|client|combined)$ ]]; then
    print_error "Invalid certificate type: $CERT_TYPE"
    echo "Valid types: server, client, combined"
    exit 1
fi

# If template flag is set, generate templates and exit
if [ "$GENERATE_TEMPLATES" = true ]; then
    generate_templates
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Validate CA
validate_ca

# Validate extension files
validate_ext_files

# Cleanup if requested
if [ "$CLEANUP_OLD" = true ]; then
    cleanup_existing
fi

# Initialize passwords file
if [ "$GENERATE_KEYSTORE" = true ] || [ "$GENERATE_JKS_KEYSTORE" = true ] || [ "$GENERATE_TRUSTSTORE" = true ] || [ -n "$KEY_PASSWORD" ]; then
    cat > "$OUTPUT_DIR/passwords.env" << EOF
# Certificate Passwords - Generated $(date)
# KEEP THIS FILE SECURE - DO NOT COMMIT TO VERSION CONTROL

EOF
    chmod 600 "$OUTPUT_DIR/passwords.env"
fi

# Generate certificates
print_info "Starting certificate generation..."
echo ""

for ((i=0; i<$NUM_INSTANCES; i++)); do
    generate_certificate $i
done

# Print summary
print_summary

print_success "All certificates generated successfully!"
echo ""